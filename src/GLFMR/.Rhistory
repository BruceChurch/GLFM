sss[2,3]<-3
sss[1,2]<-10
sss[3,2]<-3
sss
sss<-c(sss;c(1,1))
sss<-c(sss,c(1,1))
sss
sss<-matrix(1,nrow=3,ncol=2)
sss[1,2]<-10
sss[3,2]<-3
sss
cbind(sss,c(1,1))
cbind(sss,c(1,1,1))
rbind(sss,c(1,1))
sapply(sss,unique)
a<-c(1 2 3)
a<-c(1, 2, 3)
b<-c(1,,4,5)
b<-c(1,4,5)
a==b
help(isany)
help(is.any)
all.equal(a,b)
identical(a,b)
identical(a,sss)
N<-5
m0<-matrix(0,N,2)
Z <- apply(m0, c(1,2), function(x) sample(c(0,1),1,prob=c(0.2,0.8)))
Z
patterns<-sapply(Z,unique)
patterns
patterns<-sapply(t(Z),unique)
patterns
duplicated(Z)
Z[duplicated(Z),]
Z[!duplicated(Z),]
patterns<-Z[!duplicated(Z),]
which(Z==patterns[1,])
patterns
patterns[1,]
Z
identical(Z,patterns[1,])
sapply(Z,function(x){Z[x,]==patterns[1,]})
which(apply(Z, 1, function(x) all.equal(x[1:2], patterns[1,])) == "TRUE")
which(apply(Z, 1, function(x) all.equal(x[1:2], patterns[2,])) == "TRUE")
patterns
which(apply(Z, 1, function(x) all.equal(x, patterns[2,])) == "TRUE")
which(apply(Z, 1, function(x) all.equal(x, patterns[3,])) == "TRUE")
which(apply(Z, 1, function(x) all.equal(x, patterns[4,])) == "TRUE")
patterns
L <- rep(0,dim(patterns)[1])
for(r in 1:dim(patterns)[1] ){
idxs_eq<-which(apply(Z, 1, function(x) all.equal(x , patterns[r,])) == "TRUE")
C[idxs_eq]<-'r'
L[r]<-length(idx_eq)
}
L <- rep(0,dim(patterns)[1])
for(r in 1:dim(patterns)[1] ){
idxs_eq<-which(apply(Z, 1, function(x) all.equal(x , patterns[r,])) == "TRUE")
#C[idxs_eq]<-'r'
L[r]<-length(idx_eq)
}
L <- rep(0,dim(patterns)[1])
for(r in 1:dim(patterns)[1] ){
idxs_eq<-which(apply(Z, 1, function(x) all.equal(x , patterns[r,])) == "TRUE")
#C[idxs_eq]<-'r'
L[r]<-length(idxS_eq)
}
L <- rep(0,dim(patterns)[1])
for(r in 1:dim(patterns)[1] ){
idxs_eq<-which(apply(Z, 1, function(x) all.equal(x , patterns[r,])) == "TRUE")
#C[idxs_eq]<-'r'
L[r]<-length(idxs_eq)
}
L
order(L)
L[order(L)]
order(L,decreasing=TRUE)
L[order(L,decreasing=true)]
L[order(L,decreasing=TRUE)]
patterns<-patterns[order(L,decreasing=TRUE),]
patterns
C <- rep(0,N)
C
C[1]<-r
C
C[1]<-'r'
C
C[c(1,2)]<-'r'
C
rm(list=ls())
graphics.off()
setwd("~/Documents/Working_papers/FAP_Rpackage/GLFM/src/GLFMR")
require(R.matlab)
require(ggplot2)
source("GLFM_infer.R")
source("GLFM_computeMAP.R")
source("GLFM_computePDF.R")
source("GLFM_plotPatterns.R")
source("remove_dims.R")
source("get_feature_patterns_sorted.R")
source("computeLeg.R")
datos_prostate<-readMat('prostate_v3.mat')
source("init_default_params.R")
Xauxi <- as.matrix(unlist(datos_prostate$data[2,1,1]),ncol=16,nrow= 502, byrow=TRUE)
Xfull<-aux<-matrix(Xauxi,nrow=502,ncol=16)
C<-unlist(datos_prostate$data[3,1,1],use.names = FALSE)
Cfull<-strsplit(as.character(C), "")
cat_labels_full <-unlist(datos_prostate$data[4,1,1],use.names = FALSE)
y_labels_full<-unlist(datos_prostate$data[5,1,1],use.names = FALSE)
y_labels_long_full<-unlist(datos_prostate$data[6,1,1],use.names = FALSE)
idx_toKeep <- c(1, 2, 4,13, 15)
X<-Xfull[,idx_toKeep]
C<-Cfull[[1]][idx_toKeep]
aux1<-rep(paste("stage",cat_labels_full[1:2]),5)
cat_labels1<-aux1[order(aux1)]
aux2<-rep(paste(cat_labels_full[3:5], "mg"),5)
ord_labels2<-aux2[order(aux2)]
aux3<-rep(cat_labels_full[6:9],5)
cat_labels3<-aux3[order(aux3)]
y_labels<-y_labels_full[idx_toKeep]
y_labels_long<-y_labels_long_full[idx_toKeep]
N<-dim(X)[1]
D<-dim(X)[2]
plotlabels<-list(cat_labels1,ord_labels2,cat_labels3)
# pre-transform a subset of variables
#params
param_names<-c("missing","s2u","s2B","alpha","Niter","maxK","bias","transf_dummie","plotlabels")
missing<--1
s2u<-0.005
s2B<-1
alpha<-1
Niter<-1000
maxK<-10
bias<-1
transf_dummie <-TRUE
if(transf_dummie){
idx_transform <- D # we transform the last dimension
# transformation to apply to raw data
t_1<-function(x){log(x+1)}
# inverse transform to recover raw data
t_inv<-function(y){exp(y)-1}
# derivative of transform
dt_1<-function(x){1/(x+1)}
# change type of data due to transformation
ext_datatype <-'p'
param_names<-c(param_names,'t_1','dt_1','t_inv','ext_datatype','idx_transform')
params<-list(missing,s2u,s2B,alpha,Niter,maxK,bias,transf_dummie,plotlabels,t_1,dt_1,t_inv,ext_datatype,idx_transform)
} else{
params<-list(missing,s2u,s2B,alpha,Niter,maxK,bias,transf_dummie,plotlabels)
}
names(params)<-param_names
# Inference
Z<-c()
data_prost<-list("X"=X,"C"=C)
output <- GLFM_infer(data_prost, list(Z,params))
Kest <-dim(output$hidden$B[[1]])[1]
Zp <- diag(Kest)
Zp[,1] <- 1 # bias active
Zp <- Zp[1:(min(5,Kest)),]
leges <- computeLeg(Zp,c())
colours<-c('red','blue','green','pink','yellow')
Kest
Kest <-dim(output$hidden$B[[1]])[1]
Zp <- diag(Kest)
Zp[,1] <- 1 # bias active
Zp <- Zp[1:(min(5,Kest)),]
leges <- computeLeg(Zp,c())
colours<-c('red','blue','green','pink','yellow')
# Falta calcular la probabilidad empirica (es lo que llaman baseline)
GLFM_plotPatterns(data_prost,output$hidden,output$params,Zp, list("leges"=leges,"colours"=colours) )
C
rm(list=ls())
graphics.off()
setwd("~/Documents/Working_papers/FAP_Rpackage/GLFM/src/GLFMR")
require(R.matlab)
require(ggplot2)
source("GLFM_infer.R")
source("GLFM_computeMAP.R")
source("GLFM_computePDF.R")
source("GLFM_plotPatterns.R")
source("remove_dims.R")
source("get_feature_patterns_sorted.R")
source("computeLeg.R")
datos_prostate<-readMat('prostate_v3.mat')
source("init_default_params.R")
Xauxi <- as.matrix(unlist(datos_prostate$data[2,1,1]),ncol=16,nrow= 502, byrow=TRUE)
Xfull<-aux<-matrix(Xauxi,nrow=502,ncol=16)
C<-unlist(datos_prostate$data[3,1,1],use.names = FALSE)
Cfull<-strsplit(as.character(C), "")
cat_labels_full <-unlist(datos_prostate$data[4,1,1],use.names = FALSE)
y_labels_full<-unlist(datos_prostate$data[5,1,1],use.names = FALSE)
y_labels_long_full<-unlist(datos_prostate$data[6,1,1],use.names = FALSE)
idx_toKeep <- c(1, 2, 4,13, 15)
X<-Xfull[,idx_toKeep]
C<-Cfull[[1]][idx_toKeep]
aux1<-rep(paste("stage",cat_labels_full[1:2]),5)
cat_labels1<-aux1[order(aux1)]
aux2<-rep(paste(cat_labels_full[3:5], "mg"),5)
ord_labels2<-aux2[order(aux2)]
aux3<-rep(cat_labels_full[6:9],5)
cat_labels3<-aux3[order(aux3)]
y_labels<-y_labels_full[idx_toKeep]
y_labels_long<-y_labels_long_full[idx_toKeep]
N<-dim(X)[1]
D<-dim(X)[2]
plotlabels<-list(cat_labels1,ord_labels2,cat_labels3)
# pre-transform a subset of variables
#params
param_names<-c("missing","s2u","s2B","alpha","Niter","maxK","bias","transf_dummie","plotlabels")
missing<--1
s2u<-0.005
s2B<-1
alpha<-1
Niter<-1000
maxK<-10
bias<-1
transf_dummie <-TRUE
if(transf_dummie){
idx_transform <- D # we transform the last dimension
# transformation to apply to raw data
t_1<-function(x){log(x+1)}
# inverse transform to recover raw data
t_inv<-function(y){exp(y)-1}
# derivative of transform
dt_1<-function(x){1/(x+1)}
# change type of data due to transformation
ext_datatype <-'p'
param_names<-c(param_names,'t_1','dt_1','t_inv','ext_datatype','idx_transform')
params<-list(missing,s2u,s2B,alpha,Niter,maxK,bias,transf_dummie,plotlabels,t_1,dt_1,t_inv,ext_datatype,idx_transform)
} else{
params<-list(missing,s2u,s2B,alpha,Niter,maxK,bias,transf_dummie,plotlabels)
}
names(params)<-param_names
# Inference
Z<-c()
data_prost<-list("X"=X,"C"=C)
output <- GLFM_infer(data_prost, list(Z,params))
Kest <-dim(output$hidden$B[[1]])[1]
Zp <- diag(Kest)
Zp[,1] <- 1 # bias active
Zp <- Zp[1:(min(5,Kest)),]
leges <- computeLeg(Zp,c())
colours<-c('red','blue','green','pink','yellow')
# Falta calcular la probabilidad empirica (es lo que llaman baseline)
GLFM_plotPatterns(data_prost,output$hidden,output$params,Zp, list("leges"=leges,"colours"=colours) )
graphics.off()
help(rnorm)
help(pnorm)
Zp
B
hidden$B
rm(list=ls())
graphics.off()
setwd("~/Documents/Working_papers/FAP_Rpackage/GLFM/src/GLFMR")
require(R.matlab)
require(ggplot2)
source("GLFM_infer.R")
source("GLFM_computeMAP.R")
source("GLFM_computePDF.R")
source("GLFM_plotPatterns.R")
source("remove_dims.R")
source("get_feature_patterns_sorted.R")
source("computeLeg.R")
datos_prostate<-readMat('prostate_v3.mat')
source("init_default_params.R")
Xauxi <- as.matrix(unlist(datos_prostate$data[2,1,1]),ncol=16,nrow= 502, byrow=TRUE)
Xfull<-aux<-matrix(Xauxi,nrow=502,ncol=16)
C<-unlist(datos_prostate$data[3,1,1],use.names = FALSE)
Cfull<-strsplit(as.character(C), "")
cat_labels_full <-unlist(datos_prostate$data[4,1,1],use.names = FALSE)
y_labels_full<-unlist(datos_prostate$data[5,1,1],use.names = FALSE)
y_labels_long_full<-unlist(datos_prostate$data[6,1,1],use.names = FALSE)
idx_toKeep <- c(1, 2, 4,13, 15)
X<-Xfull[,idx_toKeep]
C<-Cfull[[1]][idx_toKeep]
aux1<-rep(paste("stage",cat_labels_full[1:2]),5)
cat_labels1<-aux1[order(aux1)]
aux2<-rep(paste(cat_labels_full[3:5], "mg"),5)
ord_labels2<-aux2[order(aux2)]
aux3<-rep(cat_labels_full[6:9],5)
cat_labels3<-aux3[order(aux3)]
y_labels<-y_labels_full[idx_toKeep]
y_labels_long<-y_labels_long_full[idx_toKeep]
N<-dim(X)[1]
D<-dim(X)[2]
plotlabels<-list(cat_labels1,ord_labels2,cat_labels3)
# pre-transform a subset of variables
#params
param_names<-c("missing","s2u","s2B","alpha","Niter","maxK","bias","transf_dummie","plotlabels")
missing<--1
s2u<-0.005
s2B<-1
alpha<-1
Niter<-1000
maxK<-10
bias<-1
transf_dummie <-FALSE
if(transf_dummie){
idx_transform <- D # we transform the last dimension
# transformation to apply to raw data
t_1<-function(x){log(x+1)}
# inverse transform to recover raw data
t_inv<-function(y){exp(y)-1}
# derivative of transform
dt_1<-function(x){1/(x+1)}
# change type of data due to transformation
ext_datatype <-'p'
param_names<-c(param_names,'t_1','dt_1','t_inv','ext_datatype','idx_transform')
params<-list(missing,s2u,s2B,alpha,Niter,maxK,bias,transf_dummie,plotlabels,t_1,dt_1,t_inv,ext_datatype,idx_transform)
} else{
params<-list(missing,s2u,s2B,alpha,Niter,maxK,bias,transf_dummie,plotlabels)
}
names(params)<-param_names
# Inference
Z<-c()
data_prost<-list("X"=X,"C"=C)
output <- GLFM_infer(data_prost, list(Z,params))
hidden$B
output$hidden$B
C
d<-1
B<-output$hidden$B[[1]]
theta
hidden$params$theta
output$params$theta
output$params
output$hidden
output$hidden$theta
output$hidden$s2y
output$hidden$s2y{1}
output$hidden$s2y[[1]]
pdf_c(Zp,B,1)
source("pdf_c.R")
pdf_c(Zp,B,1)
Zp
Kest <-dim(output$hidden$B[[1]])[1]
Zp <- diag(Kest)
Zp[,1] <- 1 # bias active
Zp <- Zp[1:(min(5,Kest)),]
leges <- computeLeg(Zp,c())
pdf_c(Zp,B,1)
B
Zp
dim(B)
Zp*B[,1]
Zp*B[1,]
Kest <-dim(output$hidden$B[[1]])[1]
Zp <- diag(Kest)
Zp[,1] <- 1 # bias active
Zp <- Zp[1:(min(5,Kest)),]
leges <- computeLeg(Zp,c())
colours<-c('red','blue','green','pink','yellow')
# Falta calcular la probabilidad empirica (es lo que llaman baseline)
GLFM_plotPatterns(data_prost,output$hidden,output$params,Zp, list("leges"=leges,"colours"=colours) )
rm(list=ls())
graphics.off()
setwd("~/Documents/Working_papers/FAP_Rpackage/GLFM/src/GLFMR")
require(R.matlab)
require(ggplot2)
source("GLFM_infer.R")
source("GLFM_computeMAP.R")
source("GLFM_computePDF.R")
source("GLFM_plotPatterns.R")
source("remove_dims.R")
source("get_feature_patterns_sorted.R")
source("computeLeg.R")
datos_prostate<-readMat('prostate_v3.mat')
source("init_default_params.R")
Xauxi <- as.matrix(unlist(datos_prostate$data[2,1,1]),ncol=16,nrow= 502, byrow=TRUE)
Xfull<-aux<-matrix(Xauxi,nrow=502,ncol=16)
C<-unlist(datos_prostate$data[3,1,1],use.names = FALSE)
Cfull<-strsplit(as.character(C), "")
cat_labels_full <-unlist(datos_prostate$data[4,1,1],use.names = FALSE)
y_labels_full<-unlist(datos_prostate$data[5,1,1],use.names = FALSE)
y_labels_long_full<-unlist(datos_prostate$data[6,1,1],use.names = FALSE)
idx_toKeep <- c(1, 2, 4,13, 15)
X<-Xfull[,idx_toKeep]
C<-Cfull[[1]][idx_toKeep]
aux1<-rep(paste("stage",cat_labels_full[1:2]),5)
cat_labels1<-aux1[order(aux1)]
aux2<-rep(paste(cat_labels_full[3:5], "mg"),5)
ord_labels2<-aux2[order(aux2)]
aux3<-rep(cat_labels_full[6:9],5)
cat_labels3<-aux3[order(aux3)]
y_labels<-y_labels_full[idx_toKeep]
y_labels_long<-y_labels_long_full[idx_toKeep]
N<-dim(X)[1]
D<-dim(X)[2]
plotlabels<-list(cat_labels1,ord_labels2,cat_labels3)
# pre-transform a subset of variables
#params
param_names<-c("missing","s2u","s2B","alpha","Niter","maxK","bias","transf_dummie","plotlabels")
missing<--1
s2u<-0.005
s2B<-1
alpha<-1
Niter<-1000
maxK<-10
bias<-1
transf_dummie <-TRUE
if(transf_dummie){
idx_transform <- D # we transform the last dimension
# transformation to apply to raw data
t_1<-function(x){log(x+1)}
# inverse transform to recover raw data
t_inv<-function(y){exp(y)-1}
# derivative of transform
dt_1<-function(x){1/(x+1)}
# change type of data due to transformation
ext_datatype <-'p'
param_names<-c(param_names,'t_1','dt_1','t_inv','ext_datatype','idx_transform')
params<-list(missing,s2u,s2B,alpha,Niter,maxK,bias,transf_dummie,plotlabels,t_1,dt_1,t_inv,ext_datatype,idx_transform)
} else{
params<-list(missing,s2u,s2B,alpha,Niter,maxK,bias,transf_dummie,plotlabels)
}
names(params)<-param_names
# Inference
Z<-c()
data_prost<-list("X"=X,"C"=C)
output <- GLFM_infer(data_prost, list(Z,params))
Kest <-dim(output$hidden$B[[1]])[1]
Zp <- diag(Kest)
Zp[,1] <- 1 # bias active
Zp <- Zp[1:(min(5,Kest)),]
leges <- computeLeg(Zp,c())
colours<-c('red','blue','green','pink','yellow')
# Falta calcular la probabilidad empirica (es lo que llaman baseline)
GLFM_plotPatterns(data_prost,output$hidden,output$params,Zp, list("leges"=leges,"colours"=colours) )
C
Zp*output$hidden$B[[5]]
Zp
output$hidden$B[[5]]
Zp%*%output$hidden$B[[5]]
source("pdf_g.R")
source("pdf_p.R")
source("pdf_n.R")
source("pdf_c.R")
source("pdf_o.R")
Kest <-dim(output$hidden$B[[1]])[1]
Zp <- diag(Kest)
Zp[,1] <- 1 # bias active
Zp <- Zp[1:(min(5,Kest)),]
leges <- computeLeg(Zp,c())
colours<-c('red','blue','green','pink','yellow')
# Falta calcular la probabilidad empirica (es lo que llaman baseline)
GLFM_plotPatterns(data_prost,output$hidden,output$params,Zp, list("leges"=leges,"colours"=colours) )
source("pdf_g.R")
source("pdf_p.R")
source("pdf_n.R")
source("pdf_c.R")
source("pdf_o.R")
Kest <-dim(output$hidden$B[[1]])[1]
Zp <- diag(Kest)
Zp[,1] <- 1 # bias active
Zp <- Zp[1:(min(5,Kest)),]
leges <- computeLeg(Zp,c())
colours<-c('red','blue','green','pink','yellow')
# Falta calcular la probabilidad empirica (es lo que llaman baseline)
GLFM_plotPatterns(data_prost,output$hidden,output$params,Zp, list("leges"=leges,"colours"=colours) )
source("pdf_g.R")
source("pdf_p.R")
source("pdf_n.R")
source("pdf_c.R")
source("pdf_o.R")
Kest <-dim(output$hidden$B[[1]])[1]
Zp <- diag(Kest)
Zp[,1] <- 1 # bias active
Zp <- Zp[1:(min(5,Kest)),]
leges <- computeLeg(Zp,c())
colours<-c('red','blue','green','pink','yellow')
# Falta calcular la probabilidad empirica (es lo que llaman baseline)
GLFM_plotPatterns(data_prost,output$hidden,output$params,Zp, list("leges"=leges,"colours"=colours) )
source("pdf_g.R")
source("pdf_p.R")
source("pdf_n.R")
source("pdf_c.R")
source("pdf_o.R")
source("pdf_g.R")
source("pdf_p.R")
source("pdf_n.R")
source("pdf_c.R")
source("pdf_o.R")
source("pdf_g.R")
source("pdf_p.R")
source("pdf_n.R")
source("pdf_c.R")
source("pdf_o.R")
source("pdf_g.R")
source("pdf_p.R")
source("pdf_n.R")
source("pdf_c.R")
source("pdf_o.R")
Kest <-dim(output$hidden$B[[1]])[1]
Zp <- diag(Kest)
Zp[,1] <- 1 # bias active
Zp <- Zp[1:(min(5,Kest)),]
leges <- computeLeg(Zp,c())
colours<-c('red','blue','green','pink','yellow')
# Falta calcular la probabilidad empirica (es lo que llaman baseline)
GLFM_plotPatterns(data_prost,output$hidden,output$params,Zp, list("leges"=leges,"colours"=colours) )
source("GLFM_computePDF.R")
Kest <-dim(output$hidden$B[[1]])[1]
Zp <- diag(Kest)
Zp[,1] <- 1 # bias active
Zp <- Zp[1:(min(5,Kest)),]
leges <- computeLeg(Zp,c())
colours<-c('red','blue','green','pink','yellow')
# Falta calcular la probabilidad empirica (es lo que llaman baseline)
GLFM_plotPatterns(data_prost,output$hidden,output$params,Zp, list("leges"=leges,"colours"=colours) )
graphics.off
graphics.off()
